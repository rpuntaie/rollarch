#!/usr/bin/env bash

function rollarchrootusage()
{
  echo "Required defines:"
  echo "DSK USR PW HST ZONE IP2 AIP2 BOOT SWAP ROOT UEFI KM"
  echo "Optional:"
  echo "CL LA_NG USRPKGS DOTSINSTALL ESSID PSK"
  echo ""
  echo "Functions for after arch-chroot"
  echo ""
  echo "- setup_time: using \$ZONE"
  echo "- setup_locale: using \$LA_NG"
  echo "- setup_escape: Caps_Lock becomes Escape"
  echo "- setup_network: with \$IP2 \$HST \$ESSID \$PSK; uses systemd-networkd"
  echo "- setup_boot: EFI boot if /sys/firmware/efi, else BIOS using grub"
  echo "- setup_user: using \$USR and \$PW, the latter also for root"
  echo "- setup_arch_proxy if AIP2=yes"
  echo "- setup_dots installs user dotfiles with the script \$DOTSINSTALL"
  echo "- setup_clean_meta makes \$USRPKGS '-meta' package dependencies 'asexplicit'"
  echo "- setup_all does all of the above"
  echo ""
  echo "See https://github.com/rpuntaie/rollarch[root]"
  exit 0
}

function setup_arch_proxy() 
{
  pacman -S --needed --noconfirm darkhttpd &>/dev/null
  ln -s /var/lib/pacman/sync/*.db /var/cache/pacman/pkg
  cd /usr/lib/systemd/system/
  cat darkhttpd.service | sed -e "s/Webserver/ArchProxy/g" -e "s,/srv/http.*$,/var/cache/pacman/pkg --no-server-id --port 8080,g" > ArchProxy.service
  systemctl enable --now ArchProxy &>/dev/null
}

function setup_time()
{
  LOCALTIMECONF=${LOCALTIMECONF:-/etc/localtime}
  SYSTEMTIMECONF=${SYSTEMTIMECONF:-/etc/systemd/timesyncd.conf}
  for z in $(find /usr/share/zoneinfo/ -iname "*$ZONE"); do
    if [[ ! $z =~ ^.*/right/.*$ ]] && [[ ! $z =~ ^.*/posix/.*$ ]]; then
      rm -rf $LOCALTIMECONF
      ln -s "$z" $LOCALTIMECONF
      break
    fi
  done
  hwclock --systohc
  cat > $SYSTEMTIMECONF <<EOF
[Time]
NTP=0.arch.pool.ntp.org 1.arch.pool.ntp.org 2.arch.pool.ntp.org 3.arch.pool.ntp.org
FallbackNTP=0.pool.ntp.org 1.pool.ntp.org
RootDistanceMaxSec=5
PollIntervalMinSec=32
PollIntervalMaxSec=2048
EOF
  timedatectl set-ntp true
}

function setup_locale()
{
  LOCALEGEN=${LOCALEGEN:-/etc/locale.gen}
  LOCALECONF=${LOCALECONF:-/etc/locale.conf}
  local X=$LA_NG
  X+=" en_US"
  for x in $X
  do
    sed -i -r "s/^#($x.* UTF-8)/\1/" $LOCALEGEN
  done
  locale-gen
  LC_ALL="en_US.UTF-8" locale > $LOCALECONF
}

function setup_escape()
{
  VCONSOLECONF=${VCONSOLECONF:-/etc/vconsole.conf}
  local KBD=$(find /usr/share/kbd/keymaps/i386 -iname "$KM.map*")
  cd "${KBD%/*}"
  KBD=${KBD##*/}
  KBD=${KBD%%.*}
  cp $KBD.map.gz rollarch$KBD.map.gz
  if [[ -n $CL ]]; then
    #Win: 125 on VConsole, for X: `xmodmap -e "keysym Super_L = Caps_Lock"
    #Print: 99 on VConsole, for X: `xmodmap -e "keysym Print = Caps_Lock"
    gunzip rollarch$KBD.map.gz
    sed -ie "s/keycode *58 *= *Caps_Lock/keycode 58 = Escape/g" rollarch$KBD.map
    echo "keycode $CL = Caps_Lock" >> rollarch$KBD.map
    echo "# modified: 58 = Escape and $CL = Caps_Lock" >> rollarch$KBD.map
    gzip rollarch$KBD.map
  fi
  loadkeys rollarch$KBD
  localectl set-keymap rollarch$KBD
  if [[ ! -f "$VCONSOLECONF" ]]; then
    echo "KEYMAP=rollarch$KBD" > $VCONSOLECONF
  fi
}

#for VirtualBox use bridged to have access to LAN
#netctl is configured but not started
function setup_ip()
{
  ETCNETCTLSE=${ETCNETCTLSE:-/etc/netctl/se}
  ETCNETCTLDE=${ETCNETCTLDE:-/etc/netctl/de}
  ETCNETCTLSW=${ETCNETCTLSW:-/etc/netctl/sw}
  ETCNETCTLDW=${ETCNETCTLDW:-/etc/netctl/dw}
  ETCSYSTEMDNETWORKWIRED=${ETCSYSTEMDNETWORKWIRED:-/etc/systemd/network/20-wired.network}
  ETCSYSTEMDNETWORKWIRELESS=${ETCSYSTEMDNETWORKWIRELESS:-/etc/systemd/network/25-wireless.network}
  ETCSYSTEMDSYSTEMNETWORKSERVICE=${ETCSYSTEMDSYSTEMNETWORKSERVICE:-/etc/systemd/system/network.service}
  ETCSYSTEMDRESOLVEDCONF=${ETCSYSTEMDRESOLVEDCONF:-/etc/systemd/resolved.conf}
  if [[ "$IP2" != "dhcp" ]]; then
    #IP2="1.100"
    local IPE=${IP2##*.} #100
    local IPB=${IP2%$IPE} #1.
    local NS=192.168.${IPB}1
    local CIDR="192.168.$IP2/24"
    ## #systemd-resolved instead of
    ## echo "nameserver $NS" > /etc/resolv.conf
    sed -i -e "s/#DNS=.*$/DNS=$NS/g" -e "s/#FallbackDNS/FallbackDNS/g" -e "s/#LLMNR/LLMNR/g" -e "s/#Multi/Multi/g" $ETCSYSTEMDRESOLVEDCONF
  fi
  local had_e=""
  local had_w=""
  for NIC in $(ip link show|grep " UP \| DOWN "|sed "s/^[^:]: \([^:]\+\).*/\1/g"); do
    if [[ ${NIC:0:1} == "e" ]] && [[ "$had_e" == "" ]]; then
      had_e=$NIC
      if [[ "$IP2" != "dhcp" ]]; then
        cat > $ETCNETCTLSE <<EOF
Description='static ethernet'
Interface=$NIC
Connection=ethernet
IP=static
Address=('$CIDR')
Gateway=('$NS')
DNS=('$NS')
EOF
        cat > $ETCSYSTEMDSYSTEMNETWORKSERVICE <<EOF
[Unit]
Description=Network Connectivity
Wants=network.target
Before=network.target
BindTo=sys-subsystem-net-devices-$NIC.device
After=sys-subsystem-net-devices-$NIC.device

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/bin/ip link set dev $NIC up
ExecStart=/usr/bin/ip addr add $CIDR dev $NIC
ExecStart=/usr/bin/ip route add default via $NS
ExecStop=/usr/bin/ip addr flush dev $NIC
ExecStop=/usr/bin/ip link set dev $NIC down

[Install]
WantedBy=multi-user.target
EOF
        cat > $ETCSYSTEMDNETWORKWIRED <<EOF
[Match]
Name=$NIC

[Network]
Address=$CIDR
Gateway=$NS
DNS=$NS
LLMNR=yes
MulticastDNS=yes

[Route]
Metric=10
EOF
      else
        cat > $ETCNETCTLDE <<EOF
Description='dhcp ethernet'
Interface=$NIC
Connection=ethernet
IP=dhcp
EOF
        cat > $ETCSYSTEMDNETWORKWIRED <<EOF
[Match]
Name=$NIC

[Network]
DHCP=ipv4
LLMNR=yes
MulticastDNS=yes

[DHCP]
RouteMetric=10
EOF
      fi
    elif [[ ${NIC:0:1} == "w" ]] && [[ "$had_w" == "" ]]; then
      had_w=$NIC
      if [[ "$IP2" != "dhcp" ]]; then
        cat > $ETCNETCTLSW <<EOF
Description='static wireless'
Interface=$NIC
Connection=wireless
Security=wpa
ESSID='$ESSID'
Key='$PSK'
IP=static
Address=('$CIDR')
Gateway=('$NS')
DNS=('$NS')
EOF
        cat > $ETCSYSTEMDNETWORKWIRELESS <<EOF
[Match]
Name=$NIC

[Network]
Address=$CIDR
Gateway=$NS
DNS=$NS
LLMNR=yes
MulticastDNS=yes

[Route]
Metric=20
EOF
      else
        cat > $ETCNETCTLDW <<EOF
Description='dhcp wireless'
Interface=$NIC
Connection=wireless
Security=wpa
IP=dhcp
ESSID='$ESSID'
Key='$PSK'
EOF
        cat > $ETCSYSTEMDNETWORKWIRELESS <<EOF
[Match]
Name=$NIC

[Network]
DHCP=ipv4
LLMNR=yes
MulticastDNS=yes

[DHCP]
RouteMetric=20
EOF
    ##systemd-networkd needs wpa_supplicant to connect to access point
    #wpa_cli>scan>scan_results
    #>add_network 0
    #>set_network 0 ssid <SSID>
    #>set_network 0 psk <passphrase>
    #>enable_network 0
    #>save_config>quit
    cat > etc/wpa_supplicant/wpa_supplicant-$had_w.conf <<EOF
ctrl_interface=/run/wpa_supplicant
update_config=1
#repeat for every MYSSID:
#wpa_passphrase MYSSID passphrase
#to produce ...
network={
    ssid='$ESSID'
    psk='$PSK'
}
EOF
      fi
    fi
  done
  if [[ $had_w != "" ]] && [[ $had_e != "" ]]; then
    cat > /etc/modules-load.d/bonding.conf <<EOF
bonding
EOF
    cat > /etc/modprobe.d/bonding.conf <<EOF
options bonding mode=active-backup miimon=100 primary=$had_e max_bonds=0
EOF
    cat > /etc/netctl/failover <<EOF
Description='A wired connection with failover to wireless'
Interface='failover'
Connection=bond
BindsToInterfaces=('$had_e' '$had_w')
IP='dhcp'
EOF
    cat > /etc/systemd/system/wpa_supplicant@$had_w.service.d/customdependency.conf <<EOF
[Unit]
After=netctl@failover.service
EOF
  fi
  systemctl enable --now systemd-networkd &>/dev/null
  systemctl enable --now systemd-resolved &>/dev/null
  ## FOR NETCTL
  ## #systemctl disable systemd-networkd
  ## #systemctl --type=service #to ensure no other network service is running
  ## systemctl enable --now wpa_supplicant@$had_w # OR
  ## nectl start failover #FOR EN AND WL
  ## #cat /proc/net/bonding/failover # to check status # OR
  ## if [[ "$IP2" = "dhcp" ]]; then
  ##   netctl start dw #<wifi-menu-gnerated> # OR
  ##   netctl start de # ... FOR EN ONLY
  ## else
  ##   netctl start sw # see above # OR
  ##   netctl start se # ... FOR EN
  ## fi
}

function setup_smb_ssh_nfs()
{
  ETCSAMBASMB=${ETCSAMBASMB:-/etc/samba/smb.conf}
  VARLIBSAMBAUSERSHARES=${VARLIBSAMBAUSERSHARES:-/var/lib/samba/usershares}
  LOADMODULECIFS=${LOADMODULECIFS:-/etc/modules-load.d/cifs.conf}
  echo "cifs" > $LOADMODULECIFS
  cat > $ETCSAMBASMB <<EOF
[global]
   usershare path = /var/lib/samba/usershares
   usershare max shares = 100
   usershare allow guests = yes
   usershare owner only = yes

EOF
  curl -Ls https://raw.githubusercontent.com/samba-team/samba/master/examples/smb.conf.default|sed \
    -e "s,log file = .*$,logging = systemd,g" -e "s,MYGROUP,WORKGROUP,g" -e "s/\[global\]//g" >> $ETCSAMBASMB
  mkdir -p $VARLIBSAMBAUSERSHARES
  groupadd -rf sambashare
  chown root:sambashare $VARLIBSAMBAUSERSHARES
  chmod 1770 $VARLIBSAMBAUSERSHARES
  systemctl enable --now smb nmb &>/dev/null
  systemctl enable --now sshd &>/dev/null
  #edit /etc/exports to nfs export folders
  systemctl enable --now nfs-server.service &>/dev/null
}

function setup_network()
{
  ETCHOSTS=${ETCHOSTS:-/etc/hosts}
  ETCHOSTNAME=${ETCHOSTNAME:-/etc/hostname}
  echo $HST > $ETCHOSTNAME
  cat > $ETCHOSTS <<EOF
127.0.0.1     localhost
::1           localhost
127.0.0.1     $HST.localdomain  $HST
EOF
  setup_ip
  setup_smb_ssh_nfs
}

function setup_boot()
{
  ARCHLOADERCONF=${ARCHLOADERCONF:-/boot/loader/entries/arch.conf}
  UCODE=''
  UCODE_STRING=''
  if [[ "$(cat /proc/cpuinfo | grep GenuineIntel)" != "" ]]; then
    UCODE='intel-ucode'
  elif [[ "$(cat /proc/cpuinfo | grep AuthenticAMD)" != "" ]]; then
    UCODE='amd-ucode'
  fi
  if [[ "$UCODE" != "" ]]; then
    UCODE_STRING="initrd  /${UCODE}.img
"
    pacman -S --needed --noconfirm $UCODE &>/dev/null
  fi
  if [[ "$UEFI" == "on" ]]; then
    pacman -S --needed --noconfirm efibootmgr efitools &>/dev/null
    bootctl --path=/boot install
    PARTUUID="$(blkid -s PARTUUID -o value $ROOT)"
    APPEND="options root=PARTUUID=${PARTUUID} rw quiet splash loglevel=0 console=tty2"
    echo "title   ${HST}
linux   /vmlinuz-linux
${UCODE_STRING}initrd  /initramfs-linux.img
${APPEND}" > $ARCHLOADERCONF
  else
    mkinitcpio -p linux
    grub-install --target=i386-pc --recheck $DSK &>/dev/null
    grub-mkconfig -o "/boot/grub/grub.cfg" &>/dev/null
  fi
}

function setup_user()
{
  groupadd -rf sambashare
  groupadd -rf plugdev
  useradd -m -g users -G wheel,uucp,storage,power,video,audio,lp,games,scanner,plugdev,lock,sambashare -s /usr/bin/bash $USR
  echo -e "$PW
$PW" | passwd
  echo -e "$PW
$PW" | passwd $USR
  echo -e "$PW
$PW" | smbpasswd -a $USR
  sed -i -e "s/^# *\(%wheel ALL=(ALL) ALL\)/\1/" /etc/sudoers
  if [[ -e /usr/bin/zsh ]]; then
    chsh -s /usr/bin/zsh $USR
  fi
}

function setup_dots()
{
  if [[ -e $DOTSINSTALL ]]; then
    cd "/home/$USR"
    sudo -H -u $USR bash $DOTSINSTALL
  fi
}

function setup_clean_meta()
{
  if [[ -n $USRPKGS ]]; then
    for m in $USRPKGS; do
      if [[ "$m" =~ .*-meta ]]; then
        #make explicit
        pacman -D $(LANG=C pacman -Si $m |sed -n '/Depends\ On/,/:/p'|sed '$d'|cut -d: -f2 |tr -d '>=[0-9]') --asexplicit
        pacman -R --noconfirm $m
      fi
    done
  fi
}

function setup_all()
{
  setup_time
  setup_locale
  setup_escape
  setup_network
  setup_boot

  if [[ -z "$PW" ]]; then
    PW=$(dialog --stdout --passwordbox "Enter password for $USR and root" 0 0)
  fi
  if [[ -n "$PW" ]]; then
    setup_user
  fi

  if [[ $AIP2 == "yes" ]]; then
    setup_arch_proxy
  fi

  if [[ -z $(grep -q "^flags.*\ hypervisor\ " /proc/cpuinfo) ]]; then
    systemctl enable --now vboxservice
    #in .xinitrc: VBoxClient-all && exec xmonad
  fi

  setup_dots
  setup_clean_meta
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then

  if [[ $1 == "--help" ]] || [[ $1 == "-h" ]]; then
    rollarchrootusage
  fi

  for req in DSK USR PW HST ZONE IP2 AIP2 BOOT SWAP ROOT UEFI KM
  do
    if [[ "${!req}" == "" ]]; then
      echo "${req} missing!" >&2
      exit 1
    fi
  done

  setup_all
  exit 0
fi

