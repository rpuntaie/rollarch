#!/usr/bin/env bash

# See:
# https://github.com/rpuntaie/rollarch/rollarch
#
# This file::
#   https://raw.githubusercontent.com/rpuntaie/rollarch/master/rollarch
#   https://git.io/installarch
#
# Call as root to install Arch Linux::
#   curl -OLs https://git.io/installarch
#   DSK=/dev/sda USR=A PW=B HST=C IP2=1.106 ZONE=Berlin bash installarch
#
# Required: 
#   DSK [e.g. dev/sdX]
#   USR [not "root"]
#   PW [e.g. 's$92 37d sdxG?']
#   HST host network name
#   ZONE [e.g. Vienna]
#
# Optional:
#   IP2 [e.g. 1.106] for 192.168.1.106, else "dhcp"
#   LA_NG in addition to en_US [e.g. de_DE] (none)
#   SWAP [on|off] (off), set to on for non-SSD
#   AIP2 [e.g. 1.199 | yes, to create Arch Proxy] (none)
#
# Desription:
#   - check parameters
#   - create partitions
#   - check 'custom' at 192.168.$AIP2 
#   - rankmirrors
#   - pacstrap
#   - create chroot script
#   - arch-chroot
#  
# See ``Script after arch-chroot`` further down.

raise()
{
  echo "${1}" >&2
}

ping -c 1 -W 1 8.8.8.8 > /dev/null 2>&1
if [ $? != 0 ]
then
  raise 'Fatal: Internet not available. Fix first.'
  exit 1
fi

if [ "$(which ntpdate 2> /dev/null)" != "" ]
then
  ntpdate pool.ntp.org > /dev/null 2>&1
  timedatectl set-local-rtc 1 > /dev/null 2>&1
fi

# check parameters

for req in DSK USR PW HST ZONE
do
  if [ "${!req}" = "" ]
  then
    raise "Fatal: ${req} missing!"
    exit 1
  fi
done

if [ ! -e $DSK ]
then
  raise 'Fatal: DSK wrong'
  exit 1
fi

if [ "$USR" = "root" ] || [ "$(echo $USR | sed -e 's/[a-z]//g')" != "" ]
then
  raise 'Fatal: USR wrong'
  exit 1
fi

if [ $(find /usr/share/zoneinfo -iname "*$ZONE" | wc -l) = 0 ]
then
  raise 'Fatal: ZONE wrong'
  exit 1
fi

if [[ ! "$IP2" =~ ^([0-9]+[.][0-9]+)$ ]]
then
  IP2="dhcp"
fi


if [[ ! "$AIP2" =~ ^([0-9]+[.][0-9]+)$ ]] && [[ "$AIP2" != "" ]] && [[ "$AIP2" != "no" ]]
then
  AIP2="yes"
fi

if [ "$LA_NG" != "" ]
then
  if [ "$LA_NG" = "en_US" ] || [[ ! "$LA_NG" =~ ^([a-z][a-z]_[A-Z][A-Z])$ ]]
  then
    raise 'additional LA_NG wrong'
    exit 1
  fi
fi

if [ "$SWAP" != "on" ]
then
  SWAP="off"
fi

if [ -e /sys/firmware/efi ]; then
  UEFI="on"
else
  UEFI="off"
fi

# create partitions

umount ${DSK}* 2> /dev/null
diskstart=2048s
diskpart=
dd if=/dev/zero of=$DSK bs=1 count=2048 > /dev/null 2>&1
#dd if=/dev/zero of=$DSK bs=1 count=2048
if [ "$UEFI" = "off" ]; then
  parted --script $DSK mklabel msdos > /dev/null 2>&1
else
  parted --script $DSK mklabel gpt > /dev/null 2>&1
fi
parted --script --align optimal $DSK mkpart primary fat16 $diskstart 192MiB > /dev/null 2>&1
parted $DSK set 1 boot on > /dev/null 2>&1
diskstart=192MiB
if [ "$UEFI" = "off" ]; then
  GRUB="grub"
fi
if [ "$SWAP" = "off" ]; then
  parted --script --align optimal $DSK mkpart primary ext4 $diskstart 100% > /dev/null 2>&1
  swapsize=0
else
  swapsize=$(cat /proc/meminfo | grep MemTotal | sed "s/[^:]*: *\(.*\) kB/\1000/g")
  ((swapsize=swapsize+2**30))
  swapsize=$(numfmt --to=si $swapsize)
  parted --script --align optimal $DSK mkpart primary linux-swap $diskstart $swapsize > /dev/null 2>&1
  parted --script --align optimal $DSK mkpart primary ext4 $swapsize 100% > /dev/null 2>&1
fi
BOOT=
ROOT=
for diskpart in $(ls ${DSK}*); do
  if [[ "$diskpart" =~ ^([a-z/]+([0-9]n)?[0-9]p|[a-z/]+)[0-9]$ ]]; then
    if [ "$diskpart" != "$DSK" ]; then
      if [ "$BOOT" = "" ]; then
        BOOT=$diskpart
        echo "  boot: $BOOT"
      elif [ "$SWAP" = "off" ]; then
        ROOT=$diskpart
        echo "  root: $ROOT"
      elif [ "$SWAP" != "off" ]; then
        if  [ "$SWAP" = "on" ]; then
          SWAP=$diskpart
          echo "  swap: $SWAP"
        else
          ROOT=$diskpart
          echo "  root: $ROOT"
        fi
      fi
    fi
  fi
done
if [ "$ROOT" = "" ]; then
  raise 'unable to find the partition'
  exit 1
fi
if [ "$BOOT" != "" ]; then
  if [ "$UEFI" = "off" ]; then
    mkfs -t ext2 -F $BOOT
  else
    mkfs -t vfat $BOOT
  fi
fi
if [ "$SWAP" != "off" ]; then
  yes y | mkswap $SWAP
fi
mkfs -t ext4 -F $ROOT
yes y | tune2fs -U $(cat /proc/sys/kernel/random/uuid) $ROOT
mount $ROOT /mnt
if [ "$BOOT" != "" ]; then
  mkdir -p /mnt/boot
  mount $BOOT /mnt/boot
fi

# check 'custom'
pacman -Sy --noconfirm pacman-contrib > /dev/null 2>&1 
if [[ "$AIP2" != "" ]] && [[ "$AIP2" != "yes" ]]; then
  aip2server="http://192.168.$AIP2:8080"
  echo "Server = $aip2server" > /etc/pacman.d/mirrorlist
  if [[ -n $(curl -s "$aip2server" | grep "custom\.db") ]]; then
    cat >>/etc/pacman.conf <<EOF
[custom]
SigLevel = Optional TrustAll
Server = $aip2server
EOF
  else
    aip2server=
  fi
fi

# rankmirrors
echo "Ranking mirrors ... "
MIRRORLIST_URL="https://www.archlinux.org/mirrorlist/?country=all&protocol=http&protocol=https&ip_version=4"
curl -s "$MIRRORLIST_URL" | \
    sed -e 's/^#Server/Server/' -e '/^#/d' | \
    rankmirrors -n 8 - >> /etc/pacman.d/mirrorlist
pacman -Sy

pacstrap /mnt arch-install-scripts base gptfdisk ntp nfs-utils cifs-utils samba sudo git python vim $GRUB

if [[ "$aip2server" != "" ]]; then
  cat >>/etc/pacman.conf <<EOF
[custom]
SigLevel = Optional TrustAll
Server = $aip2server
EOF
fi


# create chroot script

cat > /mnt/rollarchroot << EOF
#!/usr/bin/env bash

# Script after arch-chroot
#
# - setup_time: using \$ZONE
# - setup_locale: using \$LA_NG
# - setup_escape: Caps_Lock becomes Escape
# - setup_network: with \$IP2 and \$HST, use netctl, but also create systemd file
# - setup_boot: EFI boot if /sys/firmware/efi, else BIOS using grub
# - setup_fstab: wiht \$DSK partitions
# - setup_user: using \$USR and \$PW, the latter also for root
#
# After installation, *delete* this file or at least the line with \$PW

## see https://github.com/rpuntaie/rollarch

export DSK=$DSK
export USR=$USR
export PW='$PW'
export HST=$HST
export LA_NG=$LA_NG
export ZONE=$ZONE
export IP2=$IP2
export AIP2=$AIP2
export BOOT=$BOOT
export SWAP=$SWAP
export ROOT=$ROOT
export UEFI=$UEFI

partid() {
  blkid -g
  for info in \$(blkid -o value "\$1"); do
    if [ "\$info" != "msdos" ]; then
      echo \$info
      return
    fi
  done
}
export -f partid

setup_arch_proxy() {
 ln -s /var/lib/pacman/sync/*.db /var/cache/pacman/pkg
 cd /usr/lib/systemd/system/
 cat darkhttpd.service | sed -e "s/Webserver/ArchProxy/g" -e "s,/srv/http.*$,/var/cache/pacman/pkg --no-server-id --port 8080,g" > ArchProxy.service
 systemctl --now enable ArchProxy
}

setup_time(){
  for z in \$(find /usr/share/zoneinfo/ -iname "*\$ZONE"); do
    if [[ ! \$z =~ ^.*/right/.*$ ]] && [[ ! \$z =~ ^.*/posix/.*$ ]]
    then
      rm -rf /etc/localtime
      ln -s "\$z" /etc/localtime
      break
    fi
  done
  hwclock --systohc
  cat > /etc/systemd/timesyncd.conf << END
[Time]
NTP=0.arch.pool.ntp.org 1.arch.pool.ntp.org 2.arch.pool.ntp.org 3.arch.pool.ntp.org
FallbackNTP=0.pool.ntp.org 1.pool.ntp.org
RootDistanceMaxSec=5
PollIntervalMinSec=32
PollIntervalMaxSec=2048
END
  timedatectl set-ntp true
}
export -f setup_time

setup_locale(){
  if [ "\$LA_NG" != "" ]
  then
    cat /etc/locale.gen | grep -E "#\${LA_NG}.* UTF-8" | sed -r "s/^#(.*)/\1/" > /etc/locale.tmp
  fi
  echo 'en_US.UTF-8 UTF-8' >> /etc/locale.tmp
  mv /etc/locale.tmp /etc/locale.gen
  locale-gen
  locale > /etc/locale.conf
}
export -f setup_locale

setup_escape(){
  # change: keycode  58 = Escape
  local KBD=$(find /usr/share/kbd/keymaps/ -iname "us.map.gz")
  local olddir="\$(pwd)"
  cd "\$(dirname \$KBD)"
  KBD=\$(basename \$KBD)
  cp \$KBD rollarch\$KBD.map.gz
  gunzip rollarch\$KBD.map.gz
  sed -ie "s/keycode *58 *= *Caps_Lock/keycode 58 = Escape/g" rollarch\$KBD.map 
  gzip rollarch\$KBD.map
  cd "\$olddir"
  loadkeys rollarch\$KBD
  cat > /etc/vconsole.conf << END
KEYMAP=rollarch\$KBD
FONT=lat9w-16
FONT_MAP=8859-1_to_uni
END
}
export -f setup_escape

#for VirtualBox use bridged to make static netctl work
setup_network(){
  echo \$HST > /etc/hostname
  cat > /etc/hosts << END
127.0.0.1     localhost
::1           localhost
127.0.0.1     \$HST.localdomain  \$HST
END
  ## in case of avahi and nss-mdns:
  #sudo sed -ie "s/resolve/mdns4_minimal [NOTFOUND=return] resolve/g" /etc/nsswitch
  if [ "\$IP2" != "dhcp" ]; then
    #IP2="1.100"
    local IPE=\${IP2##*.} #100
    local IPB=\${IP2%\$IPE} #1.
    local NS=192.168.\${IPB}1
    local CIDR="192.168.\$IP2/24"
    #echo "nameserver \$NS" > /etc/resolv.conf
    sed -i -e "s/#DNS=.*$/DNS=\$NS/g" -e "s/#FallbackDNS/FallbackDNS/g" -e "s/#LLMNR/LLMNR/g" -e "s/#Multi/Multi/g" /etc/systemd/resolved.conf
    ln -sf /run/systemd/stub-resolv.conf /etc/resolv.conf
  fi
  for NIC in \$(ip link show|grep " UP \| DOWN "|sed "s/^[^:]: \([^:]\+\).*/\1/g"); do
    if [ \${NIC:0:1} = "e" ] && [ "\$had_e" = "" ]; then
      local had_e="yes"
      if [ "\$IP2" != "dhcp" ]; then
        cat > /etc/netctl/se << END
Description='static ethernet'
Interface=\$NIC
Connection=ethernet
IP=static
Address=('\$CIDR')
Gateway=('\$NS')
DNS=('\$NS')
END
        cat > /etc/systemd/system/network.service << END
[Unit]
Description=Network Connectivity
Wants=network.target
Before=network.target
BindTo=sys-subsystem-net-devices-\$NIC.device
After=sys-subsystem-net-devices-\$NIC.device

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/bin/ip link set dev \$NIC up
ExecStart=/usr/bin/ip addr add \$CIDR dev \$NIC
ExecStart=/usr/bin/ip route add default via \$NS
ExecStop=/usr/bin/ip addr flush dev \$NIC
ExecStop=/usr/bin/ip link set dev \$NIC down

[Install]
WantedBy=multi-user.target
END
        cat > /etc/systemd/network/20-wired.network << END
[Match]
Name=\$NIC

[Network]
Address=\$CIDR
Gateway=\$NS
DNS=\$NS
LLMNR=yes
MulticastDNS=yes

[Route]
Metric=10
END
      else
        cat > /etc/systemd/network/20-wired.network << END
[Match]
Name=\$NIC

[Network]
DHCP=ipv4
LLMNR=yes
MulticastDNS=yes

[DHCP]
RouteMetric=10
END
      fi
      cat > /etc/netctl/de << END
Description='dhcp ethernet'
Interface=\$NIC
Connection=ethernet
IP=dhcp
END
    elif [ \${NIC:0:1} = "w" ] && [ "\$had_w" = "" ];
      local had_w="yes"
      if [ "\$IP2" != "dhcp" ]; then
        cat > /etc/netctl/sw << END
Description='static wireless'
Interface=\$NIC
Connection=wireless
Security=wpa
ESSID='TODO'
Key='TODO'
IP=static
Address=('\$CIDR')
Gateway=('\$NS')
DNS=('\$NS')
END
        cat > /etc/systemd/network/25-wireless.network << END
[Match]
Name=\$NIC

[Network]
Address=\$CIDR
Gateway=\$NS
DNS=\$NS
LLMNR=yes
MulticastDNS=yes

[Route]
Metric=20
END
      else
        cat > /etc/netctl/dw << END
Description='dhcp wireless'
Interface=\$NIC
Connection=wireless
Security=wpa
IP=dhcp
ESSID='TODO'
Key='TODO'
END
        cat > /etc/systemd/network/25-wireless.network << END
[Match]
Name=\$NIC

[Network]
DHCP=ipv4
LLMNR=yes
MulticastDNS=yes

[DHCP]
RouteMetric=20
END
      fi
    fi
  done
  #if [[ "\$IP2" = "dhcp" ]]; then
  #  netctl --now enable d\${NIC:0:1} > /dev/null 2>&1
  #  #systemctl --now enable dhcpcd > /dev/null 2>&1
  #else
  #  netctl --now enable s\${NIC:0:1} > /dev/null 2>&1
  #  #systemctl --now enable network > /dev/null 2>&1
  #fi
  systemctl --now enable systemd-networkd > /dev/null 2>&1
  systemctl --now enable systemd-resolved > /dev/null 2>&1
  #edit /etc/exports to nfs export folders
  systemctl --now enable nfs-server.service > /dev/null 2>&1
  curl -Ls https://raw.githubusercontent.com/samba-team/samba/master/examples/smb.conf.default|sed -e "s,log file = .*$,logging = systemd,g" -e "s,MYGROUP,WORKGROUP,g" > /etc/samba/smb.conf
  #systemctl --now enable smb.service > /dev/null 2>&1
}
export -f setup_network

setup_boot(){
  pacman -S --needed --noconfirm dialog wpa_supplicant iw > /dev/null 2>&1
  UCODE=''
  UCODE_STRING=''
  if [ "\$(cat /proc/cpuinfo | grep GenuineIntel)" != "" ]; then
    UCODE='intel-ucode'
  elif [ "\$(cat /proc/cpuinfo | grep AuthenticAMD)" != "" ]; then
    UCODE='amd-ucode'
  fi
  if [ "\$UCODE" != "" ]; then
    UCODE_STRING="initrd  /\${UCODE}.img
"
    pacman -S --needed --noconfirm \$UCODE > /dev/null 2>&1
  fi
  if [ "\$UEFI" = "on" ]; then
    pacman -S --needed --noconfirm efibootmgr efitools > /dev/null 2>&1
    bootctl --path=/boot install
    PARTUUID="\$(blkid -s PARTUUID -o value \$ROOT)"
    APPEND="options root=PARTUUID=\${PARTUUID} rw quiet splash loglevel=0 console=tty2"
    echo "title   \${HST}
linux   /vmlinuz-linux
\${UCODE_STRING}initrd  /initramfs-linux.img
\${APPEND}" > /boot/loader/entries/arch.conf
  else
    mkinitcpio -p linux
    grub-install --target=i386-pc --recheck \$DSK > /dev/null 2>&1
    grub-mkconfig -o "/boot/grub/grub.cfg" > /dev/null 2>&1
  fi
  echo "cifs" > /etc/modules-load.d/cifs.conf
}
export -f setup_boot

setup_fstab(){
  if [ "\$SWAP" != "off" ]; then
    swapon \$SWAP
  fi
  genfstab -U -p / > /etc/fstab
  if [ "\$BOOT" != "" ]; then
    sed -ie "s#\$BOOT#UUID=\$(partid \$BOOT)#" /etc/fstab
  fi
  if [ "\$SWAP" != "off" ]; then
    sed -ie "s#\$SWAP#UUID=\$(partid \$SWAP)#" /etc/fstab
  fi
  sed -ie "s#\$ROOT#UUID=$(partid \$ROOT)#" /etc/fstab
  cat /etc/fstab | sed -r 's/^(# )?(\/etc|efivarfs).*//' > /etc/fstab.tmp
  mv /etc/fstab.tmp /etc/fstab
}
export -f setup_fstab

setup_user(){
  sed -i -e "s/^# *\(%wheel ALL=(ALL) ALL\)/\1/" /etc/sudoers
  echo -e "\$PW
\$PW" | passwd
  useradd -m -g users -G wheel,storage,power,video,audio,lp,games,scanner -s /bin/bash \$USR
  echo -e "\$PW
\$PW" | passwd \$USR
  echo -e "\$PW
\$PW" | smbpasswd -a \$USR
}
export -f setup_user

if [[ "\${BASH_SOURCE[0]}" == "\${0}" ]]
then
  setup_time
  setup_locale
  setup_escape
  setup_network
  setup_boot
  setup_fstab
  setup_user
  if [[ \$AIP2 = "yes" ]]; then
    setup_arch_proxy
  fi
  exit
fi

EOF

chmod a+x /mnt/rollarchroot

# arch-chroot
arch-chroot /mnt /rollarchroot
#rm -rf /mnt/rollarchroot
umount ${DSK}* 2> /dev/null
echo "
  Arch Linux is ready.

  Next

  'poweroff', remove media, boot
  delete '/rollarchroot' or at least the line containing the password
  mount -t cifs //196.168.x.yyy/share share -o username=$USR,vers=2.0
  mount -t nfs 192.168.y.zzz:/path/to/share share
  pacman -S rollarch-xmonad
"

