#!/usr/bin/env bash

declare -r myname=${0##*/}
declare -r myver='0.0.1'

usage() {
  echo "${myname} v${myver}"
  echo
  echo "This file is from:"
  echo "  https://raw.githubusercontent.com/rpuntaie/rollarch/master/rollarch"
  echo "  https://git.io/installarch"
  echo
  echo "See:"
  echo "https://github.com/rpuntaie/rollarch/rollarch"
  echo
  echo "Call as root to install Arch Linux:"
  echo "  curl -OLs https://git.io/installarch #inspect, modify, ..."
  echo "  DSK=/dev/sda USR=A PW=B HST=C IP2=1.106 ZONE=Berlin bash installarch"
  echo
  echo "All parameters following 'installarch' are Arch or custom packages."
  echo "Default: base base-devel devtools dialog wpa_supplicant ntp nfs-utils samba sudo git python vim"
  echo
  echo "If the custom repo's name is 'custom',"
  echo "'AIP2=x.y' for 192.168.x.y is the only additional parameter needed.".
  echo "'AIP2=yes' sets up an ArchProxy server instead of using one."
  echo
  echo "Required:"
  echo "  DSK [e.g. dev/sdX]"
  echo "  USR [not "root"]"
  echo "  PW [e.g. 's$92 37d sdxG?']"
  echo "  HST host network name"
  echo "  ZONE [e.g. Vienna]"
  echo
  echo "Optional:"
  echo "  SWAP [on|off] (off), set to 'on' for non-SSD"
  echo "  IP2 [e.g. 1.106] for 192.168.1.106, else 'dhcp'"
  echo "  LA_NG in addition to en_US [e.g. de_DE] (none)"
  echo "  AIP2 [e.g. 1.199 | yes, to create Arch Proxy] (none)"
  echo
  echo "Desription:"
  echo "  - check parameters"
  echo "  - create partitions"
  echo "  - check 'custom' at 192.168.$AIP2"
  echo "  - pacstrap"
  echo "  - arch-chroot"
  echo
  echo "Rankmirrors takes long, but if you accept that, uncomment the lines marked RANK"
  exit 0
}


if [[ $1 = "--help" ]] || [[ $1 = "-h" ]]; then
  usage
fi

ping -c 1 -W 1 8.8.8.8 &>/dev/null
if [ $? != 0 ]
then
  echo 'Fatal: Internet not available. Fix first.' >&2
  exit 1
fi

if [ "$(which ntpdate 2> /dev/null)" != "" ]
then
  ntpdate pool.ntp.org &>/dev/null
  timedatectl set-local-rtc 1 &>/dev/null
fi

# check parameters

for req in DSK USR PW HST ZONE
do
  if [ "${!req}" = "" ]
  then
    echo "Fatal: ${req} missing!" >&2
    exit 1
  fi
done

if [ ! -e $DSK ]
then
  echo 'Fatal: DSK wrong' >&2
  exit 1
fi

if [ "$USR" = "root" ] || [ "$(echo $USR | sed -e 's/[a-z]//g')" != "" ]
then
  echo 'Fatal: USR wrong' >&2
  exit 1
fi

if [ $(find /usr/share/zoneinfo -iname "*$ZONE" | wc -l) = 0 ]
then
  echo 'Fatal: ZONE wrong' >&2
  exit 1
fi

if [[ ! "$IP2" =~ ^([0-9]+[.][0-9]+)$ ]]
then
  IP2="dhcp"
fi


if [[ "$AIP2" = "" ]]; then
  AIP2="no"
elif [[ ! "$AIP2" =~ ^([0-9]+[.][0-9]+)$ ]] && [[ "$AIP2" != "no" ]]
then
  AIP2="yes"
fi

if [ "$LA_NG" != "" ]
then
  for la_ng in $LA_NG
  do
    if [ "$la_ng" = "en_US" ] || [[ ! "$la_ng" =~ ^([a-z][a-z]_[A-Z][A-Z])$ ]]
    then
      echo 'additional LA_NG wrong' >&2
      exit 1
    fi
  done
fi

if [ "$SWAP" != "on" ]
then
  SWAP="off"
fi

if [ -e /sys/firmware/efi ]; then
  UEFI="on"
else
  UEFI="off"
fi

# create partitions

umount ${DSK}* 2> /dev/null
diskstart=2048s
diskpart=
dd if=/dev/zero of=$DSK bs=1 count=2048 &>/dev/null
#dd if=/dev/zero of=$DSK bs=1 count=2048
if [ "$UEFI" = "off" ]; then
  parted --script $DSK mklabel msdos &>/dev/null
else
  parted --script $DSK mklabel gpt &>/dev/null
fi
parted --script --align optimal $DSK mkpart primary fat16 $diskstart 192MiB &>/dev/null
parted $DSK set 1 boot on &>/dev/null
diskstart=192MiB
if [ "$UEFI" = "off" ]; then
  GRUB="grub"
fi
if [ "$SWAP" = "off" ]; then
  parted --script --align optimal $DSK mkpart primary ext4 $diskstart 100% &>/dev/null
  swapsize=0
else
  swapsize=$(cat /proc/meminfo | grep MemTotal | sed "s/[^:]*: *\(.*\) kB/\1000/g")
  ((swapsize=swapsize+2**30))
  swapsize=$(numfmt --to=si $swapsize)
  parted --script --align optimal $DSK mkpart primary linux-swap $diskstart $swapsize &>/dev/null
  parted --script --align optimal $DSK mkpart primary ext4 $swapsize 100% &>/dev/null
fi
BOOT=
ROOT=
for diskpart in $(ls ${DSK}*); do
  if [[ "$diskpart" =~ ^([a-z/]+([0-9]n)?[0-9]p|[a-z/]+)[0-9]$ ]]; then
    if [ "$diskpart" != "$DSK" ]; then
      if [ "$BOOT" = "" ]; then
        BOOT=$diskpart
        echo "  boot: $BOOT"
      elif [ "$SWAP" = "off" ]; then
        ROOT=$diskpart
        echo "  root: $ROOT"
      elif [ "$SWAP" != "off" ]; then
        if  [ "$SWAP" = "on" ]; then
          SWAP=$diskpart
          echo "  swap: $SWAP"
        else
          ROOT=$diskpart
          echo "  root: $ROOT"
        fi
      fi
    fi
  fi
done
if [ "$ROOT" = "" ]; then
  echo 'unable to find ROOT the partition' >&2
  exit 1
fi
if [ "$SWAP" != "off" ]; then
  yes y | mkswap $SWAP
fi
mkfs -t ext4 -F $ROOT &>/dev/null
yes y | tune2fs -U $(cat /proc/sys/kernel/random/uuid) $ROOT &>/dev/null
mount $ROOT /mnt
if [ "$BOOT" = "" ]; then
  echo 'unable to find BOOT the partition' >&2
  exit 1
fi
if [ "$UEFI" = "off" ]; then
  mkfs -t ext2 -F $BOOT &>/dev/null
else
  mkfs -t vfat $BOOT &>/dev/null
fi
mkdir -p /mnt/boot
mount $BOOT /mnt/boot

# check 'custom'
PACMAN_MIRROR_LIST=${PACMAN_MIRROR_LIST:-/etc/pacman.d/mirrorlist}
mv $PACMAN_MIRROR_LIST /etc/pacman.d/mirrorlist.org
##RANK: pacman -Sy --noconfirm pacman-contrib &>/dev/null
if [[ "$AIP2" != "no" ]] && [[ "$AIP2" != "yes" ]]; then
  aip2server="http://192.168.$AIP2:8080"
  if [[ $(head -n1 /etc/pacman.d/mirrorlist.org) != "Server = $aip2server" ]]; then
    echo "Server = $aip2server" > /etc/pacman.d/mirrorlist
  fi
  if [[ $(tail -n1 /etc/pacman.conf) != "Server = $aip2server" ]] &&
     [[ -n $(curl -s "$aip2server" | grep "custom\.db") ]]; then
    cat >> /etc/pacman.conf << EOF
[custom]
SigLevel = Optional TrustAll
Server = $aip2server
EOF
  else
    aip2server=
  fi
fi

#RANK: # rankmirrors takes too long
#RANK: echo "Ranking mirrors ... "
#RANK: MIRRORLIST_URL="https://www.archlinux.org/mirrorlist/?country=all&protocol=http&protocol=https&ip_version=4"
#RANK: curl -Ls "$MIRRORLIST_URL" | \
#RANK:     sed -e 's/^#Server/Server/' -e '/^#/d' | \
#RANK:     rankmirrors -n 8 --max-time 0.1 - >> /etc/pacman.d/mirrorlist
cat /etc/pacman.d/mirrorlist.org >> $PACMAN_MIRROR_LIST
pacman -Sy

META=
if [[ "$@" != "" ]]
then
  META="$@"
  pacstrap /mnt $GRUB $@
else
  pacstrap /mnt $GRUB arch-install-scripts base base-devel devtools dialog wpa_supplicant ntp nfs-utils samba sudo git python vim zsh
fi

genfstab -t PARTUUID /mnt >> ${MNT_ETC_FSTAB:-/mnt/etc/fstab}

if [[ "$aip2server" != "" ]]; then
  cat >> ${MNT_ETC_PACMAN_CONF:-/mnt/etc/pacman.conf} << EOF
[custom]
SigLevel = Optional TrustAll
Server = $aip2server
EOF
fi

if [[ ! -e rollarchroot ]]; then
  curl -OLs https://raw.githubusercontent.com/rpuntaie/rollarch/master/rollarchroot
  chmod a+x ./rollarchroot
fi
mv ./rollarchroot /mnt/

if [[ ! $(type check_mnt_bash) =~ .*function.* ]]; then
  function check_mnt_bash()
  {
    if [[ ! -e /mnt/usr/bin/bash ]]; then
      exit 1
    fi
  }
fi

check_mnt_bash

# arch-chroot
arch-chroot /mnt bash -c "
DSK=$DSK
USR=$USR
PW='$PW'
HST=$HST
LA_NG="$LA_NG"
ZONE=$ZONE
IP2=$IP2
AIP2=$AIP2
BOOT=$BOOT
SWAP=$SWAP
ROOT=$ROOT
UEFI=$UEFI
. ./rollarchroot
setup_all
if [[ -n \$META ]]; then
  for m in \$META; do
    if [[ "\$m" =~ .*-meta ]]; then
      #make explicit
      pacman -D \$(LANG=C pacman -Si \$m |sed -n '/Depends\ On/,/:/p'|sed '\$d'|cut -d: -f2 |tr -d '>=[0-9]') --asexplicit
      pacman -R --noconfirm \$m
    fi
  done
fi
if [[ -n \$DOTS ]]; then
  cd /home/$USR
  $(curl -Ls \$DOTS)
fi
"

ln -sf /run/systemd/resolve/stub-resolv.conf /mnt/etc/resolv.conf &>/dev/null

umount $BOOT &>/dev/null
umount $ROOT &>/dev/null
echo "\033[0;32m
  Arch Linux is ready. '/rollarchroot' is still there.

  'poweroff', remove media, boot

  cifs share and mount:

  $ net usershare add cifs_share /home/$USR/path_to_cifs_share
  $ mount -t cifs //196.168.$IP2/cifs_share cifs_share -o username=$USR,vers=2.0

  nfs mount:

  $ mount -t nfs 192.168.$IP2:/home/$USR/path_to_nfs_share nfs_share

"

